{"name":"Bloomd","tagline":"A high performance C server for bloom filters","body":"Bloomd [![Build Status](https://travis-ci.org/armon/bloomd.png?branch=master)](https://travis-ci.org/armon/bloomd)\r\n=========\r\n\r\nBloomd is a high-performance C server which is used\r\nto expose bloom filters and operations over them to\r\nnetworked clients. It uses a simple ASCI protocol\r\nwhich is human readable, and similar to memcached.\r\n\r\nFeatures\r\n--------\r\n\r\n* Scalable non-blocking core allows for many connected\r\n  clients and concurrent operations\r\n* Implements scalable bloom filters, allowing dynamic filter sizes\r\n* Supports asynchronous flushes to disk for persistence\r\n* Supports non-disk backed bloom filters for high I/O\r\n* Automatically faults cold filters out of memory to save resources\r\n* Dead simple to start and administer\r\n* FAST, FAST, FAST\r\n\r\nInstall\r\n-------\r\n\r\nDownload and build from source::\r\n\r\n    $ git clone https://armon@github.com/armon/bloomd.git\r\n    $ cd bloomd\r\n    $ pip install SCons  # Uses the Scons build system, may not be necessary\r\n    $ scons\r\n    $ ./bloomd\r\n\r\nThis will generate some errors related to building the test code\r\nas it depends on libcheck. To build the test code successfully,\r\ndo the following::\r\n\r\n    $ cd deps/check-0.9.8/\r\n    $ ./configure\r\n    $ make\r\n    # make install\r\n    # ldconfig (necessary on some Linux distros)\r\n\r\nThen re-build bloomd. At this point, the test code should build\r\nsuccessfully.\r\n\r\nFor CentOS or RHEL users, the kind folks from Vortex RPM have made\r\na repo available with RPM's.\r\n\r\n* Repo: http://vortex-rpm.org/\r\n* Bloomd RPM spec: https://github.com/vortex-rpm/bloomd\r\n\r\nUsage\r\n-----\r\n\r\nBloomd can be configured using a file which is in INI format.\r\nHere is an example configuration file:\r\n\r\n    # Settings for bloomd\r\n    [bloomd]\r\n    tcp_port = 8673\r\n    data_dir = /mnt/bloomd\r\n    log_level = INFO\r\n    flush_interval = 300\r\n    workers = 2\r\n\r\n\r\nThen run bloomd, pointing it to that file:\r\n\r\n    bloomd -f /etc/bloomd.conf\r\n\r\nA full list of configuration options is below.\r\n\r\nClients\r\n----------\r\n\r\nHere is a list of known client implementations:\r\n\r\n* Python : https://github.com/kiip/bloom-python-driver\r\n* Ruby : https://github.com/SponsorPay/bloomrb\r\n* Erlang : https://github.com/armon/erl-bloomd\r\n* Go : https://github.com/geetarista/go-bloomd\r\n* Perl : https://github.com/dams/Bloomd-Client\r\n* Node.js : https://github.com/majelbstoat/node-bloomd\r\n\r\nHere is a list of \"best-practices\" for client implementations:\r\n\r\n* Maintain a set of open connections to the server to minimize connection time\r\n* Make use of the bulk operations when possible, as they are more efficient.\r\n* For long keys, it is better to do a client-side hash (SHA1 at least), and send\r\n  the hash as the key to minimize network traffic.\r\n\r\nConfiguration Options\r\n---------------------\r\n\r\nEach configuration option is documented below:\r\n\r\n * tcp\\_port : Integer, sets the tcp port to listen on. Default 8673.\r\n\r\n * port: Same as above. For compatibility.\r\n\r\n * udp\\_port : Integer, sets the udp port. Currently listened on\r\n                but otherwise unused. Default 8674.\r\n\r\n * bind\\_address: The IP to bind to. Defaults to 0.0.0.0\r\n\r\n * data\\_dir : The data directory that is used. Defaults to /tmp/bloomd\r\n\r\n * log\\_level : The logging level that bloomd should use. One of:\r\n    DEBUG, INFO, WARN, ERROR, or CRITICAL. All logs go to syslog,\r\n    and stderr if that is a TTY. Default is DEBUG.\r\n\r\n * workers : This controls the number of worker threads that are used.\r\n   Defaults to 1. If many different filters are used, it can be advantageous\r\n   to increase this to the number of CPU cores. If only a few filters are used,\r\n   the increased lock contention may reduce throughput, and a single worker\r\n   may be better.\r\n\r\n * flush\\_interval : This is the time interval in seconds in which\r\n    filters are flushed to disk. Defaults to 60 seconds. Set to 0 to\r\n    disable.\r\n\r\n * cold\\_interval : If a filter is not accessed (check or set), for\r\n    this amount of time, it is eligible to be removed from memory\r\n    and left only on disk. If a filter is accessed, it will automatically\r\n    be faulted back into memory. Set to 3600 seconds by default (1 hour).\r\n    Set to 0 to disable cold faulting.\r\n\r\n * in\\_memory : If set to 1, then all filters are in-memory ONLY by\r\n    default. This means they are not persisted to disk, and are not\r\n    eligible for cold fault out. Defaults to 0.\r\n\r\n * initial\\_capacity : If a create command does not provide an initial\r\n    capacity for a filter, this value is used. Defaults to 100K items.\r\n\r\n * default\\_probability : If a create command does not provide a false-positive\r\n    probability rate, this value is used. Defaults to 1/10K.\r\n\r\n * use\\_mmap : If set to 1, the bloomd internal buffer management\r\n    is disabled, and instead buffers use a plain mmap() and rely on\r\n    the kernel for all management. This increases data safety in the\r\n    case that bloomd crashes, but has adverse affects on performance\r\n    if the total memory utilization of the system is high. In general,\r\n    this should be left to 0, which is the default.\r\n\r\n * scale\\_size : When a bloom filter is \"scaled\" up, this is the\r\n    multiplier that is used. It should either be 2 or 4. Setting it\r\n    to 2 will conserve memory, but is slower due to the increased number\r\n    of filters that need to be checked. Defaults to 4.\r\n\r\n * probability\\_reduction : This is a subtle control value that affects the\r\n    scaling of bloom filters. It should probably not be modified. Defaults\r\n    to 0.9.\r\n\r\n\r\nProtocol\r\n--------\r\n\r\nBy default, Bloomd will listen for TCP connections on port 8673.\r\nIt uses a simple ASCII protocol that is very similar to memcached.\r\n\r\nA command has the following syntax::\r\n\r\n    cmd [args][\\r]\\n\r\n\r\nWe start each line by specifying a command, providing optional arguments,\r\nand ending the line in a newline (carriage return is optional).\r\n\r\nThere are a total of 10 commands:\r\n\r\n* create - Create a new filter (a filter is a named bloom filter)\r\n* list - List all filters or those matching a prefix\r\n* drop - Drop a filters (Deletes from disk)\r\n* close - Closes a filter (Unmaps from memory, but still accessible)\r\n* clear - Clears a filter from the lists (Removes memory, left on disk)\r\n* check|c - Check if a key is in a filter\r\n* multi|m - Checks if a list of keys are in a filter\r\n* set|s - Set an item in a filter\r\n* bulk|b - Set many items in a filter at once\r\n* info - Gets info about a filter\r\n* flush - Flushes all filters or just a specified one\r\n\r\nFor the ``create`` command, the format is::\r\n\r\n    create filter_name [capacity=initial_capacity] [prob=max_prob] [in_memory=0|1]\r\n\r\nWhere ``filter_name`` is the name of the filter,\r\nand can contain the characters a-z, A-Z, 0-9, ., _.\r\nIf an initial capacity is provided the filter\r\nwill be created to store at least that many items in the initial filter.\r\nOtherwise the configured default value will be used.\r\nIf a maximum false positive probability is provided,\r\nthat will be used, otherwise the configured default is used.\r\nYou can optionally specify in_memory to force the filter to not be\r\npersisted to disk.\r\n\r\nAs an example::\r\n\r\n    create foobar capacity=1000000 prob=0.001\r\n\r\nThis will create a filter foobar that has a 1M initial capacity,\r\nand a 1/1000 probability of generating false positives. Valid responses\r\nare either \"Done\", \"Exists\", or \"Delete in progress\". The last response\r\noccurs if a filter of the same name was recently deleted, and bloomd\r\nhas not yet completed the delete operation. If so, a client should\r\nretry the create in a few seconds.\r\n\r\nThe ``list`` command takes either no arguments or a set prefix, and returns information\r\nabout the matching filters. Here is an example response to a command::\r\n\r\n    > list foo\r\n    START\r\n    foobar 0.001 1797211 1000000 0\r\n    END\r\n\r\nWith the list prefix \"foo\", this indicates a single filter named foobar, with a probability\r\nof 0.001 of false positives, a 1.79MB size, a current capacity of\r\n1M items, and 0 current items. The size and capacity automatically\r\nscale as more items are added.\r\n\r\nThe ``drop``, ``close`` and ``clear`` commands are like create, but only takes a filter name.\r\nIt can either return \"Done\" or \"Filter does not exist\". ``clear`` can also return \"Filter is not proxied. Close it first.\".\r\nThis means that the filter is still in-memory and not qualified for being cleared.\r\nThis can be resolved by first closing the filter.\r\n\r\nCheck and set look similar, they are either::\r\n\r\n    [check|set] filter_name key\r\n\r\nThe command must specify a filter and a key to use.\r\nThey will either return \"Yes\", \"No\" or \"Filter does not exist\".\r\n\r\n\r\nThe bulk and multi commands are similar to check/set but allows for many keys\r\nto be set or checked at once. Keys must be separated by a space::\r\n\r\n    [multi|bulk] filter_name key1 [key_2 [key_3 [key_N]]]\r\n\r\nThe check, multi, set and bulk commands can also be called by their aliasses\r\nc, m, s and b respectively.\r\n\r\nThe ``info`` command takes a filter name, and returns\r\ninformation about the filter. Here is an example output::\r\n\r\n    START\r\n    capacity 1000000\r\n    checks 0\r\n    check_hits 0\r\n    check_misses 0\r\n    page_ins 0\r\n    page_outs 0\r\n    probability 0.001\r\n    sets 0\r\n    set_hits 0\r\n    set_misses 0\r\n    size 0\r\n    storage 1797211\r\n    END\r\n\r\nThe command may also return \"Filter does not exist\" if the filter does\r\nnot exist.\r\n\r\nThe ``flush`` command may be called without any arguments, which\r\ncauses all filters to be flushed. If a filter name is provided\r\nthen that filter will be flushed. This will either return \"Done\" or\r\n\"Filter does not exist\".\r\n\r\nExample\r\n----------\r\n\r\nHere is an example of a client flow, assuming bloomd is\r\nrunning on the default port using just telnet::\r\n\r\n    $ telnet localhost 8673\r\n    > list\r\n    START\r\n    END\r\n\r\n    > create foobar\r\n    Done\r\n\r\n    > check foobar zipzab\r\n    No\r\n\r\n    > set foobar zipzab\r\n    Yes\r\n\r\n    > check foobar zipzab\r\n    Yes\r\n\r\n    > multi foobar zipzab blah boo\r\n    Yes No No\r\n\r\n    > bulk foobar zipzab blah boo\r\n    No Yes Yes\r\n\r\n    > multi foobar zipzab blah boo\r\n    Yes Yes Yes\r\n\r\n    > list\r\n    START\r\n    foobar 0.000100 300046 100000 3\r\n    END\r\n\r\n    > drop foobar\r\n    Done\r\n\r\n    > list\r\n    START\r\n    END\r\n\r\n\r\nPerformance\r\n-----------\r\n\r\nAlthough extensive performance evaluations have not been done,\r\ncasual testing on a 2012 MBP with pure set/check operations\r\nallows for a throughput of at least 600K ops/sec. On Linux,\r\nresponse times can be as low as 1.5 μs.\r\n\r\nBloomd also supports multi-core systems for scalability, so\r\nit is important to tune it for the given work load. The number\r\nof worker threads can be configured either in the configuration\r\nfile, or by providing a `-w` flag. This should be set to at most\r\n2 * CPU count. By default, only a single worker is used.\r\n\r\nReferences\r\n-----------\r\n\r\nHere are some related works which we make use of:\r\n\r\n* Space/Time Trade-offs in Hash Coding with Allowable Errors (Bloom): http://www.lsi.upc.edu/~diaz/p422-bloom.pdf\r\n* Scalable Bloom Filters (Almeida et. al): http://gsd.di.uminho.pt/members/cbm/ps/dbloom.pdf\r\n* Less Hashing, Same Performance: Building a Better Bloom Filter (Kirsch and Mitzenmacher): http://www.eecs.harvard.edu/~kirsch/pubs/bbbf/esa06.pdf\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}